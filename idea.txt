






 [   ] [abc] [def]
 [ghi] [jkl] [mno]
[pqrs] [tuv] [wxyz]
 [   ] [ _ ] [   ]

[Sel] [ 7 ] [ 8 ] [ 9 ] [DEL] [CLR]
[ C ] [ 4 ] [ 5 ] [ 6 ] [ x ] [ / ]
[ B ] [ 1 ] [ 2 ] [ 3 ] [ + ] [ - ]
[ A ] [frc] [ 0 ] [ . ] [ ( ] [ = ]


sb -> built-in
sc -> custom
sa -> abandon



input -> char
inp_ver -> char or ?
inp_exe -> new_state
inp_vis -> 

abcsf.0123456789*/+-(=

# works but not the best :(

function gcd(a, b)
  if a % b >= 0.9 then
    return gcd(b, a % b)
  else
    return math.floor(b + 0.5)
  end
end



function approx(n, d, f, p)
  --print("--b--", n,d,f,p)
  if n/d > f+p or n/d < f-p then
    return n, d, 0
  end

  local gcd = gcd(n, d)
  
  --print("--c--", gcd)
  
  return n/gcd, d/gcd, gcd
end



function f(n, d, f, p)
  --print("--a--", n,d,f,p)
  local t = {0, 1, -1, 2, -2}
  
  local best_n, best_d = n, d
  local best_gcd
  
  repeat
    n, d = best_n, best_d
    best_gcd = 1
    for ii = 1, #t do
    for ij = 1, #t do
      local i, j = t[ii], t[ij]

      if n+i < 1 or d+j < 1 then goto continue end

      local new_n, new_d, new_gcd = approx(n+i, d+j, f, p)
      if new_gcd > best_gcd then
        --print(new_n, new_d, new_gcd, best_gcd)
        best_n, best_d, best_gcd = new_n, new_d, new_gcd
      end
      ::continue::
    end end
  until n == best_n and d == best_d
  
  return n, d
end



for i=0.00, 1.01, 0.001 do
  x, y = f(i * 1000, 1000, i, 0.0005)
  print(string.format("%3.0f/%4.0f   %.3f   %.4f", x, y, i, x/y))
end
